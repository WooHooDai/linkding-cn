{% load widget_tweaks %}
{% load static %}
{% load shared %}

<div class="bookmarks-form">
  {% csrf_token %}
  {{ form.auto_close|attr:"type:hidden" }}
  <!-- 标题 -->
  <div class="form-group">
    <div class="d-flex justify-between align-baseline">
      <label for="{{ form.title.id_for_label }}" class="form-label">标题</label>
      <div class="flex">
        <button id="refresh-button" class="btn btn-link suffix-button" type="button">重新获取</button>
        <button ld-clear-button data-for="{{ form.title.id_for_label }}"
                class="ml-2 btn btn-link suffix-button clear-button"
                type="button">清空
        </button>
      </div>
    </div>
    {{ form.title|add_class:"form-input"|attr:"autocomplete:off" }}
    {{ form.title.errors }}
  </div>

  <!-- 标签 -->
  <div class="form-group" ld-tag-autocomplete>
    <label for="{{ form.tag_string.id_for_label }}" class="form-label">标签</label>
    {{ form.tag_string|form_field:"help"|add_class:"form-input"|attr:"autocomplete:off"|attr:"autocapitalize:off" }}
    <div id="{{ form.tag_string.auto_id }}_help" class="form-input-hint">
      多个标签用空格隔开，<strong>不需要</strong>(#).
      如果标签不存在，它会被自动创建。
    </div>
    <div class="form-input-hint auto-tags"></div>
    {{ form.tag_string.errors }}
  </div>

  <!-- URL -->
  <div class="form-group {% if form.url.errors %}has-error{% endif %}">
    <label for="{{ form.url.id_for_label }}" class="form-label">URL</label>
    <div class="has-icon-right">
      {{ form.url|form_field:"validation"|add_class:"form-input" }}
      <i class="form-icon loading"></i>
    </div>
    {% if form.url.errors %}
      <div class="form-input-hint">
        {{ form.url.errors }}
      </div>
    {% endif %}
    <div class="form-input-hint bookmark-exists">
      该URL书签已存在。
      本页面将使用现有书签的信息填充，保存本页面将更新现有书签信息。
    </div>
  </div>
  <!-- 描述 -->
  <div class="form-group">
    <details class="description"{% if form.description.value %} open{% endif %}>
      <summary>
        <span class="form-label d-inline-block">描述</span>
        <button ld-clear-button data-for="{{ form.description.id_for_label }}"
                class="btn btn-link suffix-button clear-button"
                type="button">清空
        </button>
      </summary>
      {{ form.description|add_class:"form-input"|attr:"rows:3" }}
      {{ form.description.errors }}
    </details>
  </div>
  <div class="form-group">
    <details class="notes"{% if form.has_notes %} open{% endif %}>
      <summary>
        <span class="form-label d-inline-block">笔记</span>
      </summary>
      <label for="{{ form.notes.id_for_label }}" class="text-assistive">Notes</label>
      {{ form.notes|form_field:"help"|add_class:"form-input"|attr:"rows:8" }}
      <div id="{{ form.notes.auto_id }}_help" class="form-input-hint">
        额外的笔记，支持 Markdown 格式。
      </div>
    </details>
    {{ form.notes.errors }}
  </div>
  <div class="form-group">
    {{ form.preview_image_remote_url.as_hidden }}
    <details class="preview-image"{% if form.preview_image_remote_url.value %} open{% endif %}>
      <summary>
        <span class="form-label d-inline-block">预览图</span>
      </summary>
      <div class="preview-image-container">
        {% if preview_image_file %}
          <img id="preview-image-img"
               class="preview-image"
               src="{% static preview_image_file %}"
               alt="预览图" />
        {% else %}
          <img id="preview-image-img"
               class="preview-image"
               src="{{ form.preview_image_remote_url.value }}"
               alt="预览图" />
        {% endif %}
      </div>
    </details>
  </div>
  <div class="form-group">
    <div class="form-checkbox">
      {{ form.unread|form_field:"help" }}
      <i class="form-icon"></i>
      <label for="{{ form.unread.id_for_label }}">标为未读</label>
    </div>
    <div id="{{ form.unread.auto_id }}_help" class="form-input-hint">
      未读书签可以被过滤，并可在你读后标记为已读。
    </div>
  </div>
  {% if request.user_profile.enable_sharing %}
    <div class="form-group">
      <div class="form-checkbox">
        {{ form.shared|form_field:"help" }}
        <i class="form-icon"></i>
        <label for="{{ form.shared.id_for_label }}">分享</label>
      </div>
      <div id="{{ form.shared.auto_id }}_help" class="form-input-hint">
        {% if request.user_profile.enable_public_sharing %}
          分享给其他注册用户和匿名用户。
        {% else %}
          分享给其他注册用户。
        {% endif %}
      </div>
    </div>
  {% endif %}
  <div class="divider"></div>
  <div class="form-group d-flex justify-between">
    {% if form.is_auto_close %}
      <input type="submit" value="保存并关闭" class="btn btn-primary btn-wide">
    {% else %}
      <input type="submit" value="保存" class="btn btn-primary btn btn-primary btn-wide">
    {% endif %}
    <a href="{{ return_url }}" class="btn">取消</a>
  </div>
  <script type="application/javascript">
    /**
     * - Pre-fill title and description with metadata from website as soon as URL changes
     * - Show hint if URL is already bookmarked
     */
    (function init() {
      const urlInput = document.getElementById('{{ form.url.id_for_label }}');
      const titleInput = document.getElementById('{{ form.title.id_for_label }}');
      const descriptionInput = document.getElementById('{{ form.description.id_for_label }}');
      const notesDetails = document.querySelector('form details.notes');
      const notesInput = document.getElementById('{{ form.notes.id_for_label }}');
      const previewImageRemoteUrlInput = document.getElementById('{{ form.preview_image_remote_url.id_for_label }}');
      const unreadCheckbox = document.getElementById('{{ form.unread.id_for_label }}');
      const sharedCheckbox = document.getElementById('{{ form.shared.id_for_label }}');
      const refreshButton = document.getElementById('refresh-button');
      const bookmarkExistsHint = document.querySelector('.form-input-hint.bookmark-exists');
      const editedBookmarkId = {{ form.instance.id|default:0 }};
      let isTitleModified = !!titleInput.value;
      let isDescriptionModified = !!descriptionInput.value;

      function toggleLoadingIcon(input, show) {
        const icon = input.parentNode.querySelector('i.form-icon');
        icon.style['visibility'] = show ? 'visible' : 'hidden';
      }

      function updateInput(input, value) {
        if (!input) {
          return;
        }
        input.value = value;
        input.dispatchEvent(new Event('value-changed'));
      }

      function updateCheckbox(input, value) {
        if (!input) {
          return;
        }
        input.checked = value;
      }

      function updatePreviewImageDisplay() {
        const previewImageImg = document.getElementById('preview-image-img');
        const previewImageDetails = document.querySelector('details.preview-image');
        if (previewImageImg) {
          previewImageImg.src = previewImageRemoteUrlInput.value || '';
          previewImageImg.style.display = previewImageRemoteUrlInput.value ? '' : 'none';
        }
        if (previewImageDetails) {
          previewImageDetails.open = !!previewImageRemoteUrlInput.value;
        }
      }

      function checkUrl() {
        if (!urlInput.value) {
          return;
        }

        toggleLoadingIcon(urlInput, true);

        const websiteUrl = encodeURIComponent(urlInput.value);
        const requestUrl = `{% url 'linkding:api-root' %}bookmarks/check?url=${websiteUrl}`;
        fetch(requestUrl)
          .then(response => response.json())
          .then(data => {
            const metadata = data.metadata;
            toggleLoadingIcon(urlInput, false);

            // Display hint if URL is already bookmarked
            const existingBookmark = data.bookmark;
            bookmarkExistsHint.style['display'] = existingBookmark ? 'block' : 'none';
            refreshButton.style['display'] = existingBookmark ? 'inline-block' : 'none';

            // Prefill form with existing bookmark data
            if (existingBookmark) {
              // Workaround: tag input will be replaced by tag autocomplete, so
              // defer getting the input until we need it
              const tagsInput = document.getElementById('{{ form.tag_string.id_for_label }}');

              bookmarkExistsHint.style['display'] = 'block';
              notesDetails.open = !!existingBookmark.notes;
              document.querySelector('details.description').open = !!existingBookmark.description;
              updateInput(titleInput, existingBookmark.title);
              updateInput(descriptionInput, existingBookmark.description);
              updateInput(notesInput, existingBookmark.notes);
              updateInput(tagsInput, existingBookmark.tag_names.join(" "));
              updateCheckbox(unreadCheckbox, existingBookmark.unread);
              updateCheckbox(sharedCheckbox, existingBookmark.shared);
            } else {
              // Update title and description with website metadata, unless they have been modified
              if (metadata.url && metadata.url !== existingBookmark?.url) {
                updateInput(urlInput, metadata.url);
              }
              if (!isTitleModified) {
                updateInput(titleInput, metadata.title);
              }
              if (!isDescriptionModified) {
                updateInput(descriptionInput, metadata.description);
                document.querySelector('details.description').open = !!metadata.description;
              }
              if (metadata.preview_image && metadata.preview_image !== existingBookmark?.preview_image_remote_url) {
                updateInput(previewImageRemoteUrlInput, metadata.preview_image);
                updatePreviewImageDisplay();
              }
            }

            // Preview auto tags
            const autoTags = data.auto_tags;
            const autoTagsHint = document.querySelector('.form-input-hint.auto-tags');

            if (autoTags.length > 0) {
              autoTags.sort();
              autoTagsHint.style['display'] = 'block';
              autoTagsHint.innerHTML = `Auto tags: ${autoTags.join(" ")}`;
            } else {
              autoTagsHint.style['display'] = 'none';
            }
          });
      }

      function refreshMetadata() {
        if (!urlInput.value) {
          return;
        }

        toggleLoadingIcon(urlInput, true);

        const websiteUrl = encodeURIComponent(urlInput.value);
        const requestUrl = `{% url 'linkding:api-root' %}bookmarks/check?url=${websiteUrl}&ignore_cache=true`;

        fetch(requestUrl)
          .then(response => response.json())
          .then(data => {
            const metadata = data.metadata;
            const existingBookmark = data.bookmark;
            toggleLoadingIcon(urlInput, false);
            if (metadata.url && metadata.url !== existingBookmark?.url) {
              urlInput.value = metadata.url;
            }
            if (metadata.title && metadata.title !== existingBookmark?.title) {
              titleInput.value = metadata.title;
              titleInput.classList.add("modified");
            }
            if (metadata.description && metadata.description !== existingBookmark?.description) {
              descriptionInput.value = metadata.description;
              descriptionInput.classList.add("modified");
              document.querySelector('details.description').open = !!metadata.description;
            }
            if (metadata.preview_image && metadata.preview_image !== existingBookmark?.preview_image_remote_url) {
              updateInput(previewImageRemoteUrlInput, metadata.preview_image);
              updatePreviewImageDisplay();
            }
          });
      }

      refreshButton.addEventListener('click', refreshMetadata);

      // Fetch website metadata when page loads and when URL changes, unless we are editing an existing bookmark
      if (!editedBookmarkId) {
        checkUrl();
        urlInput.addEventListener('input', checkUrl);
        titleInput.addEventListener('input', () => {
          isTitleModified = true;
        });
        descriptionInput.addEventListener('input', () => {
          isDescriptionModified = true;
        });
      } else {
        refreshButton.style['display'] = 'inline-block';
      }
    })();

    // 输入框自动聚焦：新建书签页面聚焦URL输入框，编辑书签页面聚焦标签输入框
    function focusInput() {
      let input;
      if (window.location.pathname === '/bookmarks/new') {
        input = document.querySelector('input[name="url"]');
      } else {
        input = document.querySelector('input[name="tag_string"]');
      }
      if (input) {
          setTimeout(function() {
            input.focus();
          }, 150);
        }
    }
    document.addEventListener('turbo:render', focusInput);
    document.addEventListener('turbo:load', focusInput);
  </script>
</div>
